当时我们最早那一版虚拟列表组件，因为初始需求比较固定，因此采用的是定高的方式来写的，虽然写的时候很方便，不过灵活性上面比较差，将就能用。后面由于业务需求有变化，列表项目里面会包含一些可变内容，所以之前那种定高的方案就不再可行了，这是第一个需要优化的点，支持动态高度。另外还有就是第一版虚拟列表没有设置缓冲区，在用户滚动过快的情况下，偶尔也会出现白屏闪烁的现象，这也是需要解决的一个问题。

动态高度
先考虑能否将列表项先渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内。但是这样也不太好，预先渲染至屏幕外，再渲染至屏幕内，这会导致渲染成本增加一倍。
最后采用预估高度先行渲染的方案，先创建一个高度缓存列表，里面存储每个列表项预估的高度值，并按照这个预估值来渲染。之后有了真实高度后，在 updated 生命周期钩子方法里面更新缓存列表里面的高度值

白屏闪烁
首先我想了想为什么会出现白屏闪烁，发现主要是因为用户滚动过快，没有给新列表项的渲染留足时间，于是我在原来列表结构的基础上，添加了缓冲区，这样整个渲染区域就由可视区+缓冲区组成

长列表常见解决方案
其实所有的解决方案都是为了解决长列表的核心痛点，那就是列表项过多导致的渲染耗时，性能低下，页面卡顿
早期有一种基于时间分片的方案，例如使用 requestAnimationFrame、requestIdleCallback 这些浏览器 API，由浏览器来决定回调函数的执行时机。大量的数据会被分多次渲染，每次渲染对应一个片段。在每个片段中处理定量的数据后，就会将主线程还给浏览器，从而解决页面卡顿的问题。但是时间切片仅仅也就只能解决卡顿这个问题，你分多个时间段来渲染，渲染依然是耗时的，并且最终仍然是有大量的列表项存在于页面上，性能依然低下。
现在比较成熟且通用的方案，基本都是用虚拟列表。这种方案的原理是设置一个可视区域，然后用户在滚动列表的时候，本质上是动态修改可视区域里面的内容，所渲染的列表项数量始终是固定的，因此同时解决了渲染耗时，性能低下和页面卡顿的问题。

还有哪些优化点
在我第二版的虚拟列表实现中，仍然用的是监听 scroll 事件的方式来触发可视区域数据的更新。但是有个问题，当滚动发生后，scroll 事件会频繁的触发，很多时候会造成重复计算的问题，这在性能上面其实是一种浪费。
这里其实可以使用 IntersectionObserver 来替换监听 scroll 事件，相比 scroll，IntersectionObserver 可以设置多个阈值来检测元素进入视口的不同程度，只在必要时才进行计算，没有性能上的浪费。并且监听回调也是异步触发的。

另外还有就是不定高这一块儿，如果列表项中包含图片，并且列表高度由图片撑开，由于图片会发送网络请求，此时无法保证在获取列表项真实高度时图片是否已经加载完成，从而造成计算不准确的情况。这种情况下，需要监听列表项的大小变化从而获取真正的高度。这里可以使用 ResizeObserver 来做这一层的监听，当尺寸发生变化后，ResizeObserver 会监听到，然后可以获取每一列表项的高度。
当时之所以这一块儿没有优化，是因为这两个 API 的浏览器覆盖率较低，只有极少浏览器支持这两个 API。不过现在这两个 API 的支持度已经比较好了，可以考虑替换以前的一些做法了，当然，我也会考虑回退机制，从而支持低版本的浏览器。
