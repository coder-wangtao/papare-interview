http/0.9
最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET
GET /index.html 上面命令表示，TCP 连接(connection)建立后，客户端向服务器请求(request)网页 index.html
协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。<html> <body>Hello World</body> </html>
服务器发送完毕，就关闭 TCP 连接。
http/0.9 缺点 1.只能发送 html 2.命令单一

http/1.0
1996 年 5 月，HTTP/1.0 版本发布，内容大大增加。
首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
其次，除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段
再次，HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息(HTTP header)，用来描述一些元数据。
示例如下:
请求:
GET /index.html
User-Agent: Mozilla/5.0(Macintosh; Intel Mac Os X10 10 5)
Accept: _/_
响应:
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length:137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html> <body>Hello World</body></html>
http1.0的缺点:  
每一个tcp只能发一次请求，发送数据完毕，连接就断开，如果还想请求其他资源，就必须新建一条新的tcp连接

http/1.1
1997 年 1 月，HTTP/1.1 版本发布，它主要升级了两个功能:
//1 插久连接【这个看上面的示意图，很好理解】;
//2 管道机制【同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。】
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。
http1.1 的缺陷
虽然 1.1 版允许复用 TCP 连接，而且可以同时发送多个请求，但是服务器只有处理完一个回应，才会进行下一个回应要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"(Head-of-line blocking)
为了避免这个问题，我们一般处理方案:
一是减少请求数【合并 js，合并 css，雪碧图】
二是同时多开持久连接【资源放在多个域名下面(因为一个域名最多可以有 6 个 tcp 的连接)】

http/2
2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 的队头阻塞的问题。这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础。2015 年，http/2 正式发布。
目标:
专注于性能，最大的一个目标是在用户和网站间只用一个连接。【之前是一个域名可以有 6 个 tcp 连接，现在只用一个 tcp 连接】这样就没有握手挥手的问题;没有慢启动的问题
核心升级点:
① 二进制协议
核心:就是将数据包切开成一片一片的，然后每一片可以乱序传输;浏览器接受到所有的片后，按照片所带的序号整合为一个完整的数据包
② 多路复用（一个 tcp 链接，多个传输）
所有的请求，都复用一个 tcp 连接
③ 头压缩
在同一个 HTTP 页面中，许多资源的 Header 是高度相似的，但是在 HTTP2 之前都是不会对其进行压缩的，这使得在多次传输中白白浪费了资源来进行重复无谓的操作。
④ 服务器推送
HTTP2 还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为"服务器推送"(Server Push，也叫 Cache push)
http/2 的缺点:
1.http/2 虽然解决了应用层的队头阻塞，但是并没有解决传输层的队头阻塞只要底层是基于 tcp，tcp 就需要有确认的流程。【流水的 http，铁打的 tcp】
在应用层，虽然所有的数据包被切成一片一片，而且这些片的可以乱序传输;但是在 tcp 层，还是要将上一层的切开的片，整合为一个数据包，依然需要按照顺序去响应，依然遵循“丢包重传"机制，所以 tcp 层的队头阻塞的问题依然是存在的。而且更严重，因为为 http/2 只有一个 tcp 连接，一旦阻塞了，这个 tcp 上的所有请求都被阻塞(http1.1 是可以新建 tcp 连接)，基于这个原因，http/3 就诞生了。 2.因为是基于 tcp，所以建立连接会经过三次握手四次挥手【建立连接需要花费很多时间】

http/3
HTTP3 使用的是 QUIC 协议。QUIC 实际上就是在 UDP 基础上重写了 TCP 的功能，但是又比 TCP 更加智能，更高效的实现了 TCP 的核心功能
因为 http/3 是基于 UDP，所以就自动解决了下面两个问题
//1.建立连接时候的三次握手四次挥手
//2.队头阻塞(UDP 是无序的，无需等待)
:
① 使用 UDP 后，怎么保证连接的可靠性【tcp 是问答式，每一个请求都有确认，保证数据包的可到达】
② 没有了 tcp 的三次握手和四次挥手，怎么建立连接的【使用 DH 密钥交换算法】
