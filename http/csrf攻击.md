CSRF(Cross-Siterequest forgery)跨站请求伪造

你可以这么来理解:攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

区别 XSS 与 CSRF
XSS:利用用户对站点的信任
【对于可以的站点一般会提示是否继续访问，也就是说如果用户不信任一个站点，就不会出现 XSS 攻击】【服务器下发的脚本在客户端浏览器执行】
CSRF:利用站点对已认证身份认证的信任

防御手段
① 检查 HTTP Referer 字段
每一个请求都一个 referer 字段，记录请求的来源，后台通过这个字段，可以知道这个请求是否是合法的。这种方法很简单，但是不安全，因为这个 referer 字段是可以篡改的。
比如:我们让 nginx 给我们代理，然后就可以修改 referer.
② 添加校验 token
由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 cookie 中，而是服务器发放的 token，这个 token 是攻击者无法伪造的数据作为校验，那么攻击者就无法再运行 CSRF 攻击。
③ 使用验证码
在敏感的操作前，加上验证码，后台可以通过验证码可以防御 CSRF 攻击;这时候每次关键操作都是用户自己知道的，主动触发的。
在微信商户平台，我们配置一些敏感的操作是不是都需要给管理员的手机号发送验证码。这个方法还是很常见的。但是这种做法不是很友好

| 项目                     | XSS（跨站脚本攻击）                       | CSRF（跨站请求伪造）                       |
| ------------------------ | ----------------------------------------- | ------------------------------------------ |
| **攻击目标**             | 用户的浏览器                              | 网站的后台业务逻辑                         |
| **核心原理**             | 注入恶意 JavaScript，并在用户浏览器执行   | 利用用户已登录状态，强迫浏览器发出恶意请求 |
| **需要攻击者做什么？**   | 找到注入点（输入框、URL、评论等）插入脚本 | 引诱用户点击链接或访问攻击者页面           |
| **需要用户做什么？**     | 访问被注入的恶意页面                      | 只要访问攻击页面即可（不需要执行脚本）     |
| **是否需要用户已登录？** | 不一定                                    | **必须**（依赖 cookie）                    |
| **利用机制**             | 浏览器执行脚本无鉴别能力                  | 浏览器自动带 cookie 导致信任被滥用         |
| **损害**                 | 窃取 cookie、盗号、篡改页面               | 非授权操作：转账、修改密码、发帖等         |
| **防御重点**             | 阻止恶意 JS 注入与执行                    | 阻止未意图的跨站请求                       |
