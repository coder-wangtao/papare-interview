深拷贝
1、const newObj = JSON.parse(JSON.stringify(oldObj))
❌ 会丢 undefined / function / Symbol
❌ Date 变字符串
❌ RegExp、Map、Set 不行
❌ 循环引用直接报错
2、structuredClone
3、lodash
4、手写一个

```js
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== "object") return obj;

  if (map.has(obj)) return map.get(obj);

  const result = Array.isArray(obj) ? [] : {};
  map.set(obj, result);

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key], map);
    }
  }

  return result;
}
```

2.水平垂直居中
Flex margin:'auto'
Grid

```css
.parent {
  display: grid;
  place-items: center;
}
```

定位 + transform

3.事件循环
浏览器的事件循环是一个在JavaScript引擎和渲染引擎之间协调工作的机制。因为JavaScript是单线程的，所以所有需要被执行的操作都需要通过一定的机制来协调它们有序的进行。它的主要任务是监视调用栈（Call Stack）和任务队列（Task Queue）。当调用栈为空时，事件循环会从任务队列中取出任务执行。

1.  调用栈（Call Stack）
    JavaScript是单线程的，调用栈是一个后进先出（LIFO）的数据结构，用于存储在程序执行过程中创建的
    所有执行上下文（Execution Contexts）。每当函数被调用时，它的执行上下文就会被推入栈中。函数
    执行完毕后，其上下文会从栈中弹出。
2.  任务队列（Task Queue）
    任务队列是一种先进先出（FIFO）的数据结构，用于存储待处理的事件。这些事件可能包括用户交互事
    件（如点击、滚动等）、网络请求完成、定时器到期等。
    事件循环处理异步操作

    浏览器的事件循环通过以下步骤处理异步操作：
    执行全局脚本：加载⻚面时，浏览器会首先执行全局脚本。
    宏任务和微任务：
    宏任务（MacroTasks）：包括脚本（script）、setTimeout、setInterval、I/O、UI rendering 等。
    微任务（MicroTasks）：包括 Promise.then、MutationObserver、process.nextTick（仅在Node.js
    中）等。
    事件循环的周期：
    执行当前宏任务。
    执行完当前宏任务后，检查并执行所有微任务。在微任务执行期间产生的新的微任务也会被连续执行，
    直到微任务队列清空。
    渲染更新界面（如果有必要）。
    请求下一个宏任务，重复上述过程。

4.Node中的事件循环
浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现。
而Node中的事件循环是由是由libuv实现的，这是一个处理异步事件的C库。
我们会发现libuv中主要维护了一个EventLoop和worker threads（线程池）；
EventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等

Node宏任务微任务  
我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：
宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；
微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；
但是，Node中的事件循环中微任务队列划分的会更加精细：
next tick queue：process.nextTick；
other queue：Promise的then回调、queueMicrotask；

调用栈执行：Node.js 首先执行全局脚本或模块中的同步代码。这些代码在调用栈中执行，直到栈被清空。
处理 process.nextTick()。process.nextTick() 队列：一旦调用栈为空，Node.js 会首先处理 process.nextTick() 队列
中的所有回调。这确保了任何在同步执行期间通过 process.nextTick() 安排的回调都将在进入任何其他阶
段之前执行。

处理其他微任务：处理完 process.nextTick() 队列后，Node.js 会处理 Promise 微任务队列。这些微任
务包括由 Promise.then() 、Promise.catch() 或 Promise.finally() 安排的回调。
开始事件循环的各个阶段：
timers阶段：处理 setTimeout() 和 setInterval() 回调。
I/O 回调阶段：处理大多数类型的I/O相关回调。
poll阶段：等待新的I/O事件，处理poll队列中的事件。
check阶段：处理 setImmediate() 回调。
close回调阶段：处理如 socket.on('close', ...) 的回调。
