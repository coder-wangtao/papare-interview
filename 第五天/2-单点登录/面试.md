1.session+cookie 模式
1.1.用户在认证中心登录，用户的账号密码发给认证中心，认证中心验证账号密码是否正确，如果账号密码正确，认证中心服务端会有一个表格，叫做 session 表格，在这里创建一个键值对，key 就是 sessionId，value 就是用户的身份信息(比如用户手机号、姓名)；换句话说，只要表格里面有这么一个键值对，说明这个用户是登录过的，目前的登录状态就是有效的。之后认证中心会把 sessionId 会把通过 cookie 下发给用户。那么此时用户的 cookie 里就存了这个 sessionId
1.2 当用户访问子系统的时候，用户会通过 cookie 吧 sessionId 带过去，子系统会拿到 sessionId，子系统会向认证中心发一个请求，将 session 发给认证中心，这个时候认证中心会通过 sessionId 从表格里查，只要能查到这个用户的信息，说明目前的用户当前登录状态是有效的，否则的话是无效的。此时认证中心会把查询的结果告诉子系统，此时子系统就知道了当前用户是否是有效的，并且还会拿到用户的一些基本信息(比如用户手机号、姓名)。
1.3 这样子系统就知道用户的基本信息，同时会返回给用户一些信息(比如用户手机号、姓名、受保护的资源)。

优点：对用户有强控制(大厂用)
比如我认证中心想让一个用户下线，只需要做一件事，再 session 表格里将用户的键值对删掉，用户马上就下线了。
缺点：认证中心的压力大，用户多，要做扩容（烧钱）

2.TOKEN 模式
2.1 用户在认证中心登录，用户的账号密码发给认证中心，认证中心验证账号密码是否正确，如果账号密码正确，认证中心会生成一个 token 返回给用户，用户存起来；
2.1 当用户访问子系统的时候，会把 token 带上，子系统可以独立验证 token(通常是子系统和认证中心交换一个秘钥，那么子系统有了这个秘钥，子系统就可以自行拆解这个 token 进行验证)，所以子系统是不需要访问认证中心，认证中心的压力会变小。
优点：认证中心的压力小
优点：对用户有没有控制

3.TOKEN+refreshToken 模式
3.1 用户在认证中心登录，用户的账号密码发给认证中心，认证中心验证账号密码是否正确，如果账号密码正确，认证中心会生成两个 token，一个是过期时间比较短的 token(TOKEN)，一个是过期时间比较长的 token(refreshToken)
3.2 当用户访问子系统的时候，会把过期时间比较短的 token(TOKEN)带上，由于子系统有过期时间比较短的 token(TOKEN)的认证能力，所以子系统能够认证过期时间比较短的 token(TOKEN)，此时如果子系统认证通过，就会把用户信息(比如用户手机号、姓名、受保护的资源)返回给用户。
3.3 过期时间比较短的 token(TOKEN)一般过期时间比较短（大约 30 分钟），当用户保存的过期时间比较短的 token(TOKEN)过期了，子系统此时验证不了了，这个时候子系统要求用户用过期时间比较长的 token(refreshToken)向认证中心换新的过期时间比较短的 token(TOKEN)。此时认证中心通过认证，返回给用户新的过期时间比较短的 token(TOKEN)，这个时候用户用新的过期时间比较短的 token(TOKEN)去访问子系统。如果此时认证中心想要当前用户下线，此时就不会返回给用户新的过期时间比较短的 token(TOKEN)，此时用户拿不到新的新的过期时间比较短的 token(TOKEN)，就无法访问子系统了。
