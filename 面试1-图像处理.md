当时我们这个项目涉及到了在线的图像处理，例如对图像添加滤镜、图片变换、图片压缩这些操作。=> 专业的图像处理库

我当时首先想到了 WebAssembly，因为它是字节码格式，性能上面很有优势。在此基础上我还应用了 Web Worker、OffscreenCanvas 以及 requestIdleCallback 来做进一步优化，最终落地下来的这一套解决方案

我们使用了性能测试工具 Lighthouse 和 Chrome DevTools 的 Performance 面板来进行性能测试。优化前，处理一张 4K 分辨率的图片，之前的一个操作（例如添加滤镜）平均需要 2.5 秒，而优化后同样的处理仅需 500 毫秒左右，性能提升了约 80%。

1.WebAssembly
我先使用了 Emscripten，这是一个内置了 LLVM 工具链的编译器，可以将 C++ 代码编译成 WebAssembly. 通过这个工具，我将一个现有的 C++ 图像处理库 OpenCV 编译成 Wasm 模块，编译后还会生成一个 JS 胶水文件，之后就可以在 JS 中动态的去加载编译生成的 Wasm 模块。

2.Web Worker
由 Worker 加载 WebAssembly 模块来处理图像，处理后的图像数据传回主线程并更新 Canvas

3.OffscreenCanvas
<1>. 主线程需要将图像数据传递给 Worker 来处理。
<2>. Worker 处理完后，需要将处理后数据返回给主线程。
<3>. 主线程再将收到的图像数据绘制到 Canvas 上。
Worker 可以直接在 OffscreenCanvas 上进行图像处理和绘制，不需要将处理后的图像数据传回主线程，并且 OffscreenCanvas 里面绘制的内容会自动更新主线程中的显示

4.requestIdleCallback
因为即使图像处理是在 Worker 中执行，但主线程仍需要与 Worker 通信、传递数据。通过 requestIdleCallback，就可以确保这些任务是在浏览器空闲时进行的，减少对主线程的干扰，主线程应该优先处理来自用户的滚动呀、点击之类的效果，给予及时反馈。
